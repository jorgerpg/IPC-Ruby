# Challenge 01 — Producer/Consumer with FIFO (Ruby)

IPC (**Inter-Process Communication**) using a **named pipe (FIFO)** on Linux:

* **Producer** (interactive): sends dynamic messages (e.g., `12 + 5`, `upper hello`).
* **Consumer**: parses, processes (arithmetic & strings), prints immediately, and **logs**.
* **Backpressure & errors**: handles missing reader and full pipe.
* **Signals**: `USR1` (pause/resume), `USR2` (clear buffer), `TERM/INT` (graceful shutdown).

> Requirements covered: (3) variable data, (4) processing + log, (5) errors/blocking, (6) signals.

---

## 1) Prerequisites (Linux)

* Build tools and headers:

  ```bash
  sudo apt update
  sudo apt install -y build-essential git libssl-dev libreadline-dev zlib1g-dev
  ```

* **Ruby** (recommended via `rbenv`):

  ```bash
  # Install rbenv
  git clone https://github.com/rbenv/rbenv.git ~/.rbenv
  echo 'export PATH="$HOME/.rbenv/bin:$PATH"' >> ~/.bashrc
  echo 'eval "$(rbenv init - bash)"' >> ~/.bashrc
  exec $SHELL

  # ruby-build plugin
  git clone https://github.com/rbenv/ruby-build.git ~/.rbenv/plugins/ruby-build

  # Install and select Ruby (e.g., 3.3.0)
  rbenv install 3.3.0
  rbenv global 3.3.0
  ruby -v
  ```

* **Bundler** (optional, for tests/RSpec):

  ```bash
  gem install bundler
  ```

> On Windows, use **WSL (Ubuntu)** and follow the same steps.

---

## 2) Project structure

```
IPC-Ruby/
├─ bin/
│  ├─ producer         # interactive producer
│  └─ consumer         # consumer (processes and logs)
├─ tmp/
│  └─ ipc_fifo         # named pipe (created via mkfifo)
├─ logs/
│  └─ consumer.log     # generated by consumer
├─ Gemfile             # optional (for rspec)
└─ README.md
```

---

## 3) Project setup

From the project root:

```bash
mkdir -p tmp logs
mkfifo tmp/ipc_fifo        # create the named pipe (FIFO)
ls -l tmp/ipc_fifo         # should show type 'p'
chmod +x bin/producer bin/consumer
```

> If `tmp/ipc_fifo` exists as a regular file, delete and recreate:
> `rm -f tmp/ipc_fifo && mkfifo tmp/ipc_fifo`

**Optional (tests):**

```bash
bundle init
echo 'gem "rspec"' >> Gemfile
bundle install
bundle exec rspec --init
```

---

## 4) How to run

Open **two terminals** in the project root.

### Terminal A — consumer

```bash
./bin/consumer
```

* Prints each processed result **immediately**.
* Writes logs to `logs/consumer.log`.
* Accepts **signals** (see section 6).

### Terminal B — producer

```bash
./bin/producer
```

Type one message per line (`quit` to exit). Examples:

```
12 + 5
7*3
10 / 2
9 - 4
sum 1,2,3,4,5
upper hello world
lower TEXT
reverse abcdef
count_words foo bar baz
```

> **Tip:** send 10+ messages automatically:

```bash
./bin/producer << 'EOF'
12 + 5
7*3
10 / 2
sum 1,2,3,4
upper ruby on linux
reverse abcdef
count_words one two three four
9 - 4
3 * 3
100 / 4
quit
EOF
```

---

## 5) What the consumer understands

* **Arithmetic**: `NUM OP NUM` (`+ - * /`)

  * Supports integers and decimals (`.` as decimal separator).
  * Division by zero returns `NaN`.
* **Aggregation**: `sum 1,2,3,4` (commas and/or spaces).
* **Strings**:

  * `upper <text>` → uppercase
  * `lower <text>` → lowercase
  * `reverse <text>` → reverse string
  * `count_words <text>` → word count

Every result is **printed** and **logged** with a timestamp.

---

## 6) Signals (runtime control)

With the consumer running, get its PID:

```bash
pgrep -f bin/consumer
```

* **Pause/Resume**:

  ```bash
  kill -USR1 <PID>
  ```

  While paused, incoming messages are **buffered** (in memory).
  Send `USR1` again to resume; the consumer will **drain** the buffer.

* **Clear buffer** (discard buffered messages):

  ```bash
  kill -USR2 <PID>
  ```

* **Graceful shutdown** (final flush + metrics):

  ```bash
  kill -TERM <PID>   # or Ctrl+C (INT) in the consumer terminal
  ```

---

## 7) Blocking & error handling

* **Missing reader / EPIPE**: the producer retries opening/writing; if the consumer is absent for too long, it warns and exits.
* **Full pipe (backpressure)**: the producer uses `write_nonblock` + `IO.select` to wait until the pipe is writable, logging “pipe full” events without freezing the process.
* **Synchronous output**: the consumer’s `stdout` and its `Logger` are set to **flush immediately**.

---

## 8) Log examples

In `logs/consumer.log` you’ll see entries like:

```
I, [2025-08-18T01:23:45.678901 #1234]  INFO -- : {:id=>1, :ts=>"2025-08-18T01:23:45Z", :input=>"12 + 5", :kind=>"arith", :expr=>"12 + 5", :result=>17.0}
I, [2025-08-18T01:23:46.012345 #1234]  INFO -- : {:id=>2, :ts=>"2025-08-18T01:23:46Z", :input=>"upper hello world", :kind=>"upper", :from=>"hello world", :result=>"HELLO WORLD"}
```

---

## 9) Troubleshooting

* **`./bin/producer: Permission denied`**
  → `chmod +x bin/producer bin/consumer`

* **`FIFO not found`**
  → Recreate it: `rm -f tmp/ipc_fifo && mkfifo tmp/ipc_fifo`

* **Producer complains about missing reader**
  → Start the **consumer** first or let the producer **retry** (it will attempt a few times).

* **Consumer doesn’t print immediately**
  → Ensure `$stdout.sync = true` and the `Logger` is set to sync (already configured in this project).

* **Decimals with comma don’t parse**
  → Use a **dot** as the decimal separator: `3.5 + 1.2`.

---

## 10) How it works (technical overview)

* Communication via **named pipe (FIFO)** created with `mkfifo`.
* **Producer** opens FIFO for writing; sends **JSON** per line; uses `write_nonblock` + `IO.select` to handle a **full pipe**; handles `EPIPE` when the consumer dies.
* **Consumer** reads lines (`io.gets`), parses JSON, matches commands with **regex**, prints and logs with `Logger`.
* **Signals** via `Signal.trap` provide **pause/resume**, **buffer clear**, and **graceful shutdown**.

---

## 11) Tests (optional)

If you initialized RSpec:

```bash
bundle exec rspec
```

> You can add unit specs for `process_message` and counters/metrics.
