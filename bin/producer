#!/usr/bin/env ruby
# frozen_string_literal: true

require "json"      # Codificação de mensagens
require "time"      # Timestamps em formato ISO 8601
require "timeout"   # Controle de tempo de espera na escrita

# Caminho do pipe nomeado usado para comunicação
FIFO = "tmp/ipc_fifo"

# Verifica se o pipe existe antes de iniciar
abort("FIFO não encontrado: #{FIFO}") unless File.pipe?(FIFO)

# Sinal PIPE: evita falha se o consumidor fechar o pipe
trap("PIPE") do
  abort "[produtor] pipe quebrado (consumer fechou). Encerrando."
end

# Tenta abrir o pipe para escrita, com múltiplas tentativas
def open_fifo_for_write
  tries = 0
  begin
    File.open(FIFO, File::WRONLY | File::NONBLOCK)
  rescue Errno::ENXIO, Errno::EPIPE
    tries += 1
    warn "[produtor] sem leitor ainda... tentativa #{tries}"
    sleep 0.5
    retry if tries < 10
    abort "[produtor] não há leitor (consumer); abortando após #{tries} tentativas."
  end
end

# Escreve uma linha JSON no pipe, lidando com bloqueios e timeouts
def write_json_line(io, line, timeout: 1.0, max_retries: 5)
  pending = line.dup # Cria uma cópia da linha para poder modificar.
  retries = 0

  loop do
    begin
      # Tenta escrever os dados pendentes sem bloquear.
      written = io.write_nonblock(pending)
      # Se o número de bytes escritos for igual ao tamanho total, a escrita foi bem-sucedida.
      return if written == pending.bytesize
      # Se a escrita foi parcial, atualiza a string 'pending' para conter apenas o que falta.
      pending = pending.byteslice(written..-1)
    rescue IO::WaitWritable, Errno::EAGAIN # Erro que indica que o pipe está cheio.
      warn "[produtor] pipe cheio; aguardando disponibilidade..."
      # Usa IO.select para esperar que o 'io' (pipe) se torne disponível para escrita.
      # O timeout evita que o programa fique bloqueado indefinidamente.
      ready = IO.select(nil, [io], nil, timeout)
      unless ready
        # Se o timeout for atingido, incrementa o contador de retentativas.
        retries += 1
        warn "[produtor] ainda bloqueado (tentativa #{retries}/#{max_retries})"
        # Se o número máximo de retentativas for atingido, lança um erro.
        raise Timeout::Error, "timeout escrevendo no pipe" if retries >= max_retries
      end
      # Tenta a escrita novamente.
      retry
    end
  end
end

# Instruções para o usuário
puts "== Produtor (digite uma mensagem por linha; 'quit' para sair) =="
puts "Exemplos numéricos:  '12 + 5', '7*3', '10 / 2', '9 - 4'"
puts "Exemplos string:     'upper Olá mundo', 'reverse abc', 'count_words foo bar baz'"
puts "Outros exemplos:     'sum 1,2,3,4'"

# Prepara o pipe para escrita
io = open_fifo_for_write
io.sync = true
$stdout.sync = true

count = 0

# Loop principal de leitura do terminal
loop do
  print "> "
  line = STDIN.gets
  break if line.nil?

  line = line.strip
  break if line.downcase == "quit"
  next if line.empty?

  # Monta a mensagem a ser enviada
  payload = {
    id:  (count += 1),                # ID sequencial.
    raw: line,                        # O comando bruto digitado pelo usuário.
    ts:  Time.now.utc.iso8601,        # Timestamp universal.
    rnd: rand(1..10_000)              # Um número aleatório.
  }

  begin
    write_json_line(io, payload.to_json + "\n")
    puts "[enviado] #{payload}"
  rescue Errno::EPIPE # Erro que acontece se o consumidor fechar o pipe inesperadamente.
    warn "[produtor] consumidor fechou o pipe (EPIPE). reabrindo..."
    io = open_fifo_for_write
    io.sync = true
    retry # Tenta reenviar a mesma mensagem.
  rescue Timeout::Error => e # Erro lançado por 'write_json_line' se houver timeout.
    warn "[produtor] #{e.message}; descartando esta linha"
  end
end

# Fecha o pipe se ele não estiver fechado.
io.close unless io.closed?
puts "Produtor finalizado."
