#!/usr/bin/env ruby
# frozen_string_literal: true

require "json"    # Manipulação de mensagens em formato JSON
require "logger"  # Registro de atividades e erros
require "time"    # Formatação de timestamps em padrão ISO 8601

# Evita buffering na saída padrão (útil para logs em tempo real)
$stdout.sync = true

# Caminho do pipe nomeado e configuração do logger com rotação de arquivos
FIFO = "tmp/ipc_fifo"
LOG  = Logger.new("logs/consumer.log", 10, 1024 * 1024)

# Força escrita imediata no arquivo de log
begin
  logdev = LOG.instance_variable_get(:@logdev)
  logdev.dev.sync = true if logdev && logdev.dev.respond_to?(:sync=)
rescue
  # Ignora se a API interna do Logger mudar
end

# Verifica se o pipe existe antes de iniciar
abort("FIFO não encontrado: #{FIFO}") unless File.pipe?(FIFO)

# Estado do consumidor
$paused     = false      # Indica se o processamento está pausado
$shutdown   = false      # Indica se o consumidor deve encerrar
$processed  = 0          # Contador de mensagens processadas
$buffer     = []         # Armazena mensagens enquanto pausado
$max_buffer = 1000       # Limite máximo de mensagens no buffer

# Sinal USR1: alterna entre pausa e retomada
Signal.trap("USR1") do
  $paused = !$paused
  puts $paused ? "[signal] USR1: consumidor PAUSADO" : "[signal] USR1: consumidor RETOMADO"
  # Ao retomar, processa imediatamente o buffer
  drain_buffer unless $paused || $shutdown
end

# Sinal USR2: limpa o buffer de mensagens pendentes
Signal.trap("USR2") do
  dropped = $buffer.size
  $buffer.clear
  puts "[signal] USR2: buffer limpo (#{dropped} mensagens descartadas)"
end

# Sinais TERM e INT: encerramento gracioso (kill ou Ctrl+C)
["TERM", "INT"].each do |sig|
  Signal.trap(sig) do
    puts "[signal] #{sig}: encerramento solicitado"
    $shutdown = true
  end
end

# Interpreta e executa comandos recebidos
def process_message(msg)
  raw = msg["raw"].to_s

  # Expressões aritméticas simples (ex: "10 + 5")
  if raw =~ /\A\s*(-?\d+(?:\.\d+)?)\s*([+\-*\/])\s*(-?\d+(?:\.\d+)?)\s*\z/
    a = $1.to_f; op = $2; b = $3.to_f
    result = case op
             when "+" then a + b
             when "-" then a - b
             when "*" then a * b
             when "/" then (b.zero? ? Float::NAN : a / b)
             end
    return { kind: "arith", expr: raw, result: result }
  end

  # Comando "sum" com lista de números (ex: "sum 1,2,3")
  if raw =~ /\Asum\s+([\d,\s\.]+)\z/i
    nums = $1.split(/[\s,]+/).reject(&:empty?).map!(&:to_f)
    return { kind: "sum", list: nums, result: nums.sum }
  end

  # Manipulação de strings
  if raw =~ /\Aupper\s+(.+)\z/i
    return { kind: "upper", from: $1, result: $1.upcase }
  end
  if raw =~ /\Alower\s+(.+)\z/i
    return { kind: "lower", from: $1, result: $1.downcase }
  end
  if raw =~ /\Areverse\s+(.+)\z/i
    return { kind: "reverse", from: $1, result: $1.reverse }
  end
  if raw =~ /\Acount_words\s+(.+)\z/i
    words = $1.split(/\s+/)
    return { kind: "count_words", from: $1, result: words.size }
  end

  # Comando desconhecido
  { kind: "unknown", raw: raw }
end

# Registra e exibe o resultado do processamento
def log_and_print(hash)
  LOG.info(hash)
  puts "[proc] #{hash}"
end

# Processa uma linha recebida do pipe
def handle_line(line)
  begin
    msg = JSON.parse(line)

    if $paused
      # Armazena no buffer se estiver pausado
      if $buffer.size < $max_buffer
        $buffer << msg
        log_and_print(kind: "buffered", input: msg["raw"], size: $buffer.size)
      else
        # Descarta se o buffer estiver cheio
        log_and_print(kind: "buffer_overflow_drop", input: msg["raw"], size: $buffer.size)
      end
      return
    end

    # Processa normalmente
    result = process_message(msg)
    $processed += 1
    sleep 1  # Simula tempo de processamento
    log_and_print(id: msg["id"], ts: Time.now.utc.iso8601, input: msg["raw"], **result)
  rescue JSON::ParserError
    log_and_print(kind: "error", reason: "json_parse_error", line: line)
  rescue => e
    log_and_print(kind: "error", reason: e.class.name, message: e.message)
  end
end

# Processa mensagens pendentes no buffer
def drain_buffer
  while !$buffer.empty? && !$paused
    handle_line($buffer.shift.to_json)
  end
end

# Loop principal: escuta o pipe e processa mensagens
File.open(FIFO, "r") do |io|
  io.sync = true

  while !$shutdown
    readable, = IO.select([io], nil, nil, 0.2)

    if readable
      line = io.gets
      break if line.nil? || $shutdown
      handle_line(line)
      drain_buffer unless $paused || $shutdown
    end
  end
end

# Finaliza processando o que restou no buffer
drain_buffer unless $paused
puts "Consumer finalizado. Processados: #{$processed}"
