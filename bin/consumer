#!/usr/bin/env ruby
# frozen_string_literal: true
require "json"
require "logger"

$stdout.sync = true

FIFO = "tmp/ipc_fifo"
LOG  = Logger.new("logs/consumer.log", 10, 1024 * 1024)

# tornar o arquivo de log síncrono também (sem buffer):
begin
  logdev = LOG.instance_variable_get(:@logdev)
  logdev.dev.sync = true if logdev && logdev.dev.respond_to?(:sync=)  # <<< LOG IMEDIATO
rescue
  # ignora se a API interna do Logger mudar em outra versão
end

abort("FIFO não encontrado: #{FIFO}") unless File.pipe?(FIFO)

$paused     = false
$shutdown   = false
$processed  = 0
$buffer     = []   # armazena mensagens quando pausado
$max_buffer = 1000 # limite de segurança para não crescer indefinidamente

Signal.trap("USR1") do
  $paused = !$paused
  puts $paused ? "[signal] USR1: consumidor PAUSADO" : "[signal] USR1: consumidor RETOMADO"
end

Signal.trap("USR2") do
  dropped = $buffer.size
  $buffer.clear
  puts "[signal] USR2: buffer limpo (#{dropped} mensagens descartadas)"
end

["TERM", "INT"].each do |sig|
  Signal.trap(sig) do
    puts "[signal] #{sig}: encerramento solicitado"
    $shutdown = true
  end
end

def process_message(msg)
  raw = msg["raw"].to_s

  if raw =~ /\A\s*(-?\d+(?:\.\d+)?)\s*([+\-*\/])\s*(-?\d+(?:\.\d+)?)\s*\z/
    a = $1.to_f; op = $2; b = $3.to_f
    result = case op
             when "+" then a + b
             when "-" then a - b
             when "*" then a * b
             when "/" then (b.zero? ? Float::NAN : a / b)
             end
    return { kind: "arith", expr: raw, result: result }
  end

  if raw =~ /\Asum\s+([\d,\s\.]+)\z/i
    nums = $1.split(/[\s,]+/).reject(&:empty?).map!(&:to_f)
    return { kind: "sum", list: nums, result: nums.sum }
  end

  if raw =~ /\Aupper\s+(.+)\z/i
    return { kind: "upper", from: $1, result: $1.upcase }
  end
  if raw =~ /\Alower\s+(.+)\z/i
    return { kind: "lower", from: $1, result: $1.downcase }
  end
  if raw =~ /\Areverse\s+(.+)\z/i
    return { kind: "reverse", from: $1, result: $1.reverse }
  end
  if raw =~ /\Acount_words\s+(.+)\z/i
    words = $1.split(/\s+/)
    return { kind: "count_words", from: $1, result: words.size }
  end

  { kind: "unknown", raw: raw }
end

def log_and_print(hash)
  LOG.info(hash)
  puts "[proc] #{hash}"         # <<< COM $stdout.sync = true, sai na hora
end

def handle_line(line)
  begin
    msg = JSON.parse(line)
    if $paused
      if $buffer.size < $max_buffer
        $buffer << msg
        log_and_print(kind: "buffered", input: msg["raw"], size: $buffer.size)
      else
        log_and_print(kind: "buffer_overflow_drop", input: msg["raw"], size: $buffer.size)
      end
      return
    end

    result = process_message(msg)
    $processed += 1
    sleep 1  # simula processamento lento
    log_and_print(id: msg["id"], ts: Time.now.utc.iso8601, input: msg["raw"], **result)
  rescue JSON::ParserError
    log_and_print(kind: "error", reason: "json_parse_error", line: line)
  rescue => e
    log_and_print(kind: "error", reason: e.class.name, message: e.message)
  end
end

def drain_buffer
  while !$buffer.empty? && !$paused
    handle_line($buffer.shift.to_json)
  end
end

File.open(FIFO, "r") do |io|
  io.sync = true # garante que a leitura seja imediata
  # loop responsivo a sinais: checa $shutdown a cada ~200ms
  while !$shutdown
    # espera até 0.2s por dados; se nada chegar, volta e checa $shutdown
    readable, = IO.select([io], nil, nil, 0.2)

    if readable
      line = io.gets
      break if line.nil? || $shutdown  # writer fechou ou sinal chegou
      handle_line(line)
      drain_buffer unless $paused || $shutdown
    end
  end
end

# flush final
drain_buffer unless $paused
puts "Consumer finalizado. Processados: #{$processed}"
